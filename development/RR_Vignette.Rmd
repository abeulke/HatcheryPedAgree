---
title: "RR Vignette"
output: html_notebook
---
Data files made in "RR_Steelhead_07-20_1.rmd"


Going to remove 7 SNPs and then re-run snppit
Remove: 
  * SH109243-222
  * OMY_PEPA-INT6
  * SH128851-273
  * SH120950-569
  * SH110201-359
  * SH131965-120
  * SH97954-618
Code for this is in RR_steelhead_07-20_1.Rmd

```{r}
library(tidyverse)
library(HatcheryPedAgree)

#Genotypes and metadata
rrsh_genotypes_rm7 <- read_rds("/Users/annebeulke/Documents/Russian-River-R/Russian-River/RR_steelhead_2007-2020_geno_rm7.rds")
rrsh_metadata <- read_rds("/Users/annebeulke/Documents/Russian-River-R/Russian-River/RR_steelhead_2007-2020_meta.rds")
```

```{r}
rrsh_genotypes_rm7 %>% arrange(allele_int) 
# check what variable is used for missing data
# for HatcheryPedAgree, we need the missing data variable to be NA

library(naniar)
genos_na_rm7 <- rrsh_genotypes_rm7 %>% replace_with_na(replace = list(allele_int = 0))
```

```{r}
#next, check the number for loci for each individual
miss_dsn <- genos_na_rm7 %>%
  group_by(indiv) %>%
  summarise(
    num_all_loci = n() / 2,  # double check to make sure each gene copy is explicitly listed as NA
    num_non_miss_loci = sum(!is.na(allele_int)) / 2)

count(miss_dsn, num_all_loci)  # good.  Everyone has 87 loci

#check the amount of missing loci in the dataset
full_histo <- ggplot(miss_dsn, aes(x = num_non_miss_loci)) +
  geom_histogram(binwidth = 1)
full_histo
```
```{r}
# lets get the distribution of matching proportions with an intial run of [find_matching_samples()]
for_histo_rm7 <- find_matching_samples(genos_na_rm7, min_frac_matching = 0.8, return_clusters = TRUE)
#0.57% of allelic data identified as missing

for_histo_rm7$pairs
for_histo_rm7$clusters 
for_histo_rm7$aliases

# check the distribution
matching_data_rm7 <- for_histo_rm7$pairs %>%
  mutate(frac_match = num_match / num_non_miss)

ggplot(data = matching_data_rm7, aes(x = frac_match)) +
  geom_histogram(binwidth = 0.005)+
  scale_x_continuous(breaks = seq(0.80,1.0,0.01))+
  theme(axis.text.x = element_text(angle = 45,  hjust=1))

matching_data_rm7 

```

Now I want to attach some meta data for indiv_1 and indiv_2 to the matching sample analyses to check the output
```{r}
rrsh_metadata
matching_data_rm7

ind_one <- rrsh_metadata %>% 
  setNames(paste0("indiv_1_", names(.))) %>% 
  rename(indiv_1 = indiv_1_indiv)
ind_two <- rrsh_metadata %>% 
  setNames(paste0("indiv_2_", names(.))) %>% 
  rename(indiv_2 = indiv_2_indiv)

match_data_meta_rm7 <- matching_data_rm7 %>% 
  left_join(ind_one, by = "indiv_1") %>% 
  left_join(ind_two, by = "indiv_2")

match_data_meta_rm7
#this can be a useful document to assess the matching samples
```  


```{r}
# get the clusters of matching genotypes each indvidual belongs to
#choose an appropriate value for min_frac_matching based on the results in for_histo above
for_real_rm7 <- find_matching_samples(genos_na_rm7, min_frac_matching = 0.94, return_clusters = TRUE)
# we will end up using the identified clusters
for_real_rm7$clusters %>% arrange(desc(cluster)) #520 clusters
names(for_real_rm7)
for_real_rm7$pairs
for_real_rm7$aliases
```  
```{r}
#changed view of the date
rrsh_metadata$spawner_group <-  format(rrsh_metadata$spawner_group, "%m/%d/%y")

#now we want to reogranize the matching samples to have a single ID per cluster
reorg_rm7 <- reorganize_matching_samples(genotypes = genos_na_rm7, metadata = rrsh_metadata , clusters = for_real_rm7$clusters)
#Some matching genotypes found in different hatcheries. See cross_hatchery_matches in output.
#Some matching genotypes found to have different sexes. See cross_sex_matches in output.
#Rendered 8 genotypes NA because of mismatching homozygotes in the matching samples analysis  
###8 homoz switches were changed to NA since we don't know which homozygote is the true allele in the genotype

names(reorg_rm7)
reorg_rm7$matchers_metadata
reorg_rm7$cross_hatchery_matches
reorg_rm7$cross_sex_matches
reorg_rm7$geno_discord
reorg_rm7$snppit_meta
reorg_rm7$snppit_genos  
```  

SNPPIT: run SAD, noSAD, noSADnoHatch
```{r}  
# For this dataset we ran SNPPIT with sex and date infromation (SAD), without sex and date info (noSAD), and without sex, date, or hatchery information (noSADnoHatch)
snppit_sad_rm7 <- run_snppit(reorg_rm7$snppit_genos, reorg_rm7$snppit_meta)
snppit_sad_rm7  
results_sad_rm7 <- slurp_snppit(snppit_sad_rm7, reorg_rm7$snppit_meta) 

write_rds(results_sad_rm7, path = "../outputs/RR_SAD_results_rm7.rds", compress = "xz")  

snppit_noSAD_rm7 <- run_snppit(
  reorg_rm7$snppit_genos, 
  reorg_rm7$snppit_meta, 
  use_spawner_group = FALSE,
  use_sex = FALSE
  )
results_no_sad_rm7 <- slurp_snppit(snppit_noSAD_rm7, reorg_rm7$snppit_meta)
write_rds(results_no_sad_rm7, path = "../outputs/RR_no_SAD_results_rm7.rds", compress = "xz")  
```  
SNPPIT noSADnoHatch:
```{r}
#If the hatchery infromation is removed, you can't run SNPPIT with the function "run_snppit", so the code is here...

G <- reorg_rm7$snppit_genos
S <- reorg_rm7$snppit_meta
use_spawner_group  <-  FALSE
use_sex  <-  FALSE
min_age <- 1
max_age  <-  6
geno_err  <-  0.005
outf  <-  tempfile()

  # these will get changed if we don't use them
  sex_col <- "POPCOLUMN_SEX"
  spawn_group_col <- "POPCOLUMN_SPAWN_GROUP"


  # first, make a genotype matrix. Put spaces between the gene copies in a locus
  M <- G %>%
    select(indiv, locus, gene_copy, allele_int) %>%
    mutate(allele_int = ifelse(is.na(allele_int), 0, allele_int)) %>%
    spread(key = gene_copy, value = allele_int) %>%
    unite(col = "geno", `1`, `2`, sep = " ") %>%
    spread(key = locus, value = geno)

  # get the marker names
  SNP_names <- colnames(M)[-1]

  # prep the sex and spawn date data, and also deal with years, which could
  # be a character string.
  meta <- S %>%
    mutate(
      sex = recode(sex, Female = "F", Male = "M"),
      sex = ifelse(is.na(sex), "?", sex),
    ) %>%
    arrange(year, spawner_group) %>%
    select(hatchery, indiv, sex, year, spawner_group) %>%
    mutate(
      years_list = str_split(year, ","),
      min_year = map_int(years_list, function(x) min(as.integer(x))),
      max_year = map_int(years_list, function(x) max(as.integer(x)))
      )

  # make sure genotype data are available for all the individuals in the metadata
  these_have_no_genos <- meta %>%
    anti_join(M, by = "indiv")
  if (nrow(these_have_no_genos) > 0) {
    stop(
      "Error.  S in prepare_snppit_file is requesting addition of fish with no genotypes in G: ",
      paste(these_have_no_genos$indiv, collapse = ", ")
    )
  }

  # break the genos into candidate parents and offspring.
  # Basically if your latest spawn year is less than the min year + the
  # min age, then you don't get to be an offspring.  Likewise, if
  # your earliest spawn year is greater than max year - min age, you don't get
  # to be a candidate parent
  Offs <- meta %>%
    filter(max_year >= min(min_year) + min_age) %>%
    select(-sex, -spawner_group) %>%
    mutate(age_range = str_c(min_age, "-", max_age)) %>%
    left_join(., M, by = "indiv")

  Pars <- meta %>%
    filter(min_year <= max(max_year) - min_age) %>%
    left_join(., M, by = "indiv")


  if (use_sex == FALSE) {
    sex_col <- ""
    Pars <- Pars %>% select(-sex)
  }
  if (use_spawner_group == FALSE) {
    spawn_group_col <- ""
    Pars <- Pars %>% select(-spawner_group)
  }


  # now assemble the text ouput
  preamble <- glue::glue("
    NUMLOCI {length(SNP_names)}
    MISSING_ALLELE 0
    {sex_col}
    POPCOLUMN_REPRO_YEARS
    {spawn_group_col}
    OFFSPRINGCOLUMN_SAMPLE_YEAR
    OFFSPRINGCOLUMN_AGE_AT_SAMPLING\n
    ")

  cat(preamble, file = outf)
  write.table(
    cbind(SNP_names, geno_err),
    row.names = FALSE,
    col.names = FALSE,
    quote = FALSE,
    file = outf,
    append = TRUE
  )

  # cycle over the different hatcheries that might be involved
  # and put in a block of parents for each
  
  dump <-
    write.table(select(Pars, -hatchery, -years_list, -min_year, -max_year),
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE,
      file = outf, append = TRUE, sep = "\t"
    )
  



  # then do the same thing for offspring from the different hatcheries.  And,
  # for now, assume that the offspring could have come from any of the hatcheries
  # (hence the ? after the Offspring name)
  dump <- lapply(split(Offs, Offs$hatchery), function(x) {
    cat("OFFSPRING Offspring-", x$hatchery[1], " ?\n", file = outf, append = TRUE, sep = "")
    write.table(select(x, -hatchery, -years_list, -min_year, -max_year),
      row.names = FALSE,
      col.names = FALSE,
      quote = FALSE,
      file = outf, append = TRUE, sep = "\t"
    )
  })

  # message to user
  #message("snppit input file written to ", outf)
  outf
  #outf gives a file location, open the file at this location
  ##Then add "POP Parents" before the list of parents, just after the list of loci
```  
Now we need to run snppit with this new file I made...
enter the outf file location in the snppit_path "-f" command
```{r}
  additional_args <-  ""

  outdir <-  tempfile()

  dir.create(outdir, recursive = TRUE)

  outf <- file.path(outdir, "snppit_input.txt")

  snppit_path <- system.file("bin/snppit-Darwin", package = "HatcheryPedAgree")

  call <- paste(
    "cd", outdir, ";",
    snppit_path, "-f", "/var/folders/mc/dg9t08s57ns7sqrqxr5g3mb80000gn/T//RtmpzKI5k1/file6c0237c01bb7", additional_args
    )

  system(call)

outdir
```
```{r}
results_no_sad_rm7_nohatch <- slurp_snppit(outdir, reorg_rm7$snppit_meta)
write_rds(results_no_sad_rm7_nohatch, path = "../outputs/RR_no_SAD_results_rm7_nohatch.rds", compress = "xz")  
results_no_sad_rm7_nohatch 
```

Next look at the Mendelian Incompatabilites in each output
```{r}
results_sad_rm7 %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se") %>% 
  arrange(FDR) %>% 
  mutate(idx = 1:n()) %>% 
  ggplot(., aes(x= idx, y = FDR))+
  geom_point()
  
MI.info <- results_sad_rm7 %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se", FDR <= 0.01) %>% 
  mutate(MI_list = str_split(MendIncLoci, ",")) %>% 
  arrange(desc(MI.Trio))

MI.info %>%   
  count(MendIncLoci) %>% 
  arrange(desc(n))  %>% 
  ggplot()+ 
  geom_histogram(aes(x = n), binwidth = 1)+
  xlim(0,400)

trios_sep <- separate_rows(MI.info, MendIncLoci, sep=",")
trios_count <- trios_sep %>%
 group_by(MendIncLoci) %>%
 count()
MI.info %>% tally()
#13294 
trios_count <- trios_count %>%
 ungroup() %>%
 mutate(total = 13294)
trios_count <- trios_count %>%
 mutate(frequency = (n/total),
        percent = ((n/total)*100))
trios_count %>% arrange(desc(percent))

write_csv(trios_count, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/MI_sad_rm7_sex_data_added.csv")

trios_count %>% 
  filter(!is.na(MendIncLoci)) %>% 
  ggplot() +
  geom_histogram(aes(x = n), binwidth = 1)
```  

```{r}
results_no_sad_rm7 %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se") %>% 
  arrange(FDR) %>% 
  mutate(idx = 1:n()) %>% 
  ggplot(., aes(x= idx, y = FDR))+
  geom_point()
  
MI.info <- results_no_sad_rm7 %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se", FDR <= 0.01) %>% 
  mutate(MI_list = str_split(MendIncLoci, ",")) %>% 
  arrange(desc(MI.Trio))

MI.info %>%   
  count(MendIncLoci) %>% 
  arrange(desc(n))  %>% 
  ggplot()+ 
  geom_histogram(aes(x = n), binwidth = 1)+
  xlim(0,400)

trios_sep <- separate_rows(MI.info, MendIncLoci, sep=",")
trios_count <- trios_sep %>%
 group_by(MendIncLoci) %>%
 count()
MI.info %>% tally()
#12582
trios_count <- trios_count %>%
 ungroup() %>%
 mutate(total = 12582)
trios_count <- trios_count %>%
 mutate(frequency = (n/total),
        percent = ((n/total)*100))
trios_count %>% arrange(desc(percent))

write_csv(trios_count, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/MI_no_sad_rm7_sex_data_added.csv")

trios_count %>% 
  filter(!is.na(MendIncLoci)) %>% 
  ggplot() +
  geom_histogram(aes(x = n), binwidth = 1)
```

Next, look at number of MI in teh noSADnoHatch results
```{r}
results_no_sad_rm7_nohatch %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se") %>% 
  arrange(FDR) %>% 
  mutate(idx = 1:n()) %>% 
  ggplot(., aes(x= idx, y = FDR))+
  geom_point()
  
MI.info <- results_no_sad_rm7_nohatch %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se", FDR <= 0.01) %>% 
  mutate(MI_list = str_split(MendIncLoci, ",")) %>% 
  arrange(desc(MI.Trio))

MI.info %>%   
  count(MendIncLoci) %>% 
  arrange(desc(n))  %>% 
  ggplot()+ 
  geom_histogram(aes(x = n), binwidth = 1)+
  xlim(0,400)

trios_sep <- separate_rows(MI.info, MendIncLoci, sep=",")
trios_count <- trios_sep %>%
 group_by(MendIncLoci) %>%
 count()
MI.info %>% tally()
#11922
trios_count <- trios_count %>%
 ungroup() %>%
 mutate(total = 11922)
trios_count <- trios_count %>%
 mutate(frequency = (n/total),
        percent = ((n/total)*100))
trios_count %>% arrange(desc(percent))

write_csv(trios_count, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/MI_no_sad_rm7_no_hatch_sex_data_added.csv")

trios_count %>% 
  filter(!is.na(MendIncLoci)) %>% 
  ggplot() +
  geom_histogram(aes(x = n), binwidth = 1)

```


Then, reformat the noSAD and noSADnoHatch datasets
```{r}
reformat_no_sad_rm7 <- reformat_no_sex_or_date_results(results_no_sad_rm7)
reformat_no_sad_rm7_nohatch <- reformat_no_sex_or_date_results(results_no_sad_rm7_nohatch)
```

For this project, I used the SAD and noSADnoHatch results 
(In most studies you will want to keep the hatchery information and use the noSAD results. My study location had a complicated hatchery situation where this metadata could be incorrect)

Now compare the sad and noSadnoHatch snppit results and form the final pedigree
```{r}
#sad and noSADnoHatch
#first make comprison file
reformat_no_sad_rm7_nohatch
results_sad_rm7

conAll.edit <- results_sad_rm7 %>% 
  mutate(Kid_Ma_Pa = stringr::str_c(kid,ma,pa, sep = "_")) %>% 
  arrange(kid)
uAll.edit <- reformat_no_sad_rm7_nohatch  %>% 
  mutate(Kid_Ma_Pa = stringr::str_c(kid,ma,pa, sep = "_")) %>% 
  mutate(Kid_Pa_Ma= stringr::str_c(kid,pa,ma, sep = "_")) %>% 
  arrange(kid)

RRdiff <- conAll.edit %>% 
  mutate(Compare = ifelse(((conAll.edit$Kid_Ma_Pa == uAll.edit$Kid_Pa_Ma) | (conAll.edit$Kid_Ma_Pa == uAll.edit$Kid_Ma_Pa)), yes = "Same", no = "Different"))

diff_un_rename <- rename_at(uAll.edit, vars(-kid), function(x) paste0(x,"_no_hatch"))
diff_un_rename
comparison <- inner_join(RRdiff, diff_un_rename, "kid") %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se" & FDR <= 0.01 | MaxP.Pr.Relat_no_hatch == "C_Se_Se" & FDR_no_hatch <= 0.01)

#change the number range for i to match the total number of "kids" in teh comparison file
i <-  1:13520 #number of samples in comparison
Sad_noSadnoHatch_comp <- comparison %>%  
  mutate(Un_Diff_Hatchery = ifelse(pa_hatchery_no_hatch[i] != ma_hatchery_no_hatch[i], yes = "Parents from Different Hatcheries", no = "Same Hatchery"))
Sad_noSadnoHatch_comp %>% filter(Compare == "Same") 
Sad_noSadnoHatch_comp %>% filter(Compare == "Different"| is.na(Compare)) 

#write the comparison file to a csv and look at the differences between the SAD and noSADnoHatch results
#write_csv(noSad_noSadnoHatch_comp,"../outputs/noSad_noSadnoHatch_comp.csv")
```

Now, to quantify the differences between the runs, use the partition_two_snppit_results
```{r}
results_sad_rm7 <- read_rds("../outputs/RR_SAD_results_rm7.rds")
reformat_no_sad_rm7_nohatch <- read_rds("../outputs/RR_no_SAD_results_rm7_nohatch.rds")
partition_two_snppit_results(results_sad_rm7, reformat_no_sad_rm7_nohatch, FDR1 = 0.01, FDR2 = 0.01)
```

Now lets form the final pedigree based off decisions made about the differences in the comparisons of SAD and noSADnoHatch
```{r}
##Now try and form a pedigree
same_trios_in_both <- Sad_noSadnoHatch_comp %>% filter(Compare == "Same") %>% select(kid) 

#when there is no data for the SAD results, keep the noSADnoHatch results:
sadNA <- Sad_noSadnoHatch_comp %>% filter(is.na(Compare)) %>% select(kid)

# when the SAD run found a trio, but it did not meet the criteria of C_Se_Se + FDR<=0.01 and the noSADnoHatch run assigned different parents that did meet the criteria.  In these cases, we assume the noSADnoHatch trio is correct
unconKeep <- Sad_noSadnoHatch_comp %>% filter(Compare == "Different") %>% 
  filter(FDR > 0.01 | MaxP.Pr.Relat != "C_Se_Se") %>% 
  filter(FDR_no_hatch <= 0.01, MaxP.Pr.Relat_no_hatch == "C_Se_Se") %>%  
  select(kid) #38; still 38

same_trios_in_both; sadNA; unconKeep

uncon_trio <- bind_rows(sadNA, unconKeep)


trios1 <- results_sad_rm7 %>% right_join(same_trios_in_both, by = "kid")

trios2 <- reformat_no_sad_rm7_nohatch %>% right_join(uncon_trio, by = "kid")

trios1 %>% filter(FDR > 0.01) #zero
trios2 %>% filter(FDR > 0.01) #zero

#To get my pedigree in good working order, I will need to make two columns for kid_year, and then calculate ages
RR_Pedigree_noHatch <- bind_rows(trios1, trios2) %>% 
  separate(col = kid_year, into = c("kid_year", "kid_year2"), sep = ",") %>% 
  mutate(kid_year = as.numeric(kid_year), kid_age = kid_year - SpawnYear)
RR_Pedigree_noHatch %>% count(kid_age)

RR_Pedigree_noHatch 
```

Now, check for issues related to fish returning to more than one hatchery
```{r}
RR_Pedigree_noHatch %>% 
  filter(grepl("Coyote_Valley|Warm_Springs", kid))
# this list of kids are in here twice...they should have the same parents for both parent assignments. They have two ids because they were recorded at more than one hatchery. This fish spawned at both hatcheries
#M065002, M108189, M108351, M109166, M109175, M109610
kids_to_check <- c("M065002", "M108189", "M108351", "M109166", "M109175", "M109610")
RR_Pedigree_noHatch %>% 
  filter(grepl("M065002|M108189|M108351|M109166|M109175|M109610", kid))
#The parent assignments are identical for each pair, I will now need to remove these duplicates from the pedigree data
```
Now I need to remove the six duplicates from the total data set. This should take the data from 13480 to 13474 trios
```{r}
rm_these <- RR_Pedigree_noHatch %>% 
  filter(grepl("Coyote_Valley|Warm_Springs", kid))

RR_Ped <- RR_Pedigree_noHatch %>% 
  anti_join(rm_these, by = "kid")  
  
```

##Okay now I'm going to look at the MI counts in the pedigree I chose: RR pedigree from SAD and noHatch data
```{r}
RR_Ped
RR_Ped %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se") %>% 
  arrange(FDR) %>% 
  mutate(idx = 1:n()) %>% 
  ggplot(., aes(x= idx, y = FDR))+
  geom_point()
  
MI.info <- RR_Ped %>% 
  filter(MaxP.Pr.Relat == "C_Se_Se", FDR <= 0.01) %>% 
  mutate(MI_list = str_split(MendIncLoci, ",")) %>% 
  arrange(desc(MI.Trio))

MI.info %>%   
  count(MendIncLoci) %>% 
  arrange(desc(n))  %>% 
  ggplot()+ 
  geom_histogram(aes(x = n), binwidth = 1)+
  xlim(0,400)

trios_sep <- separate_rows(MI.info, MendIncLoci, sep=",")
trios_count <- trios_sep %>%
 group_by(MendIncLoci) %>%
 count()
MI.info %>% tally()
#13474
trios_count <- trios_count %>%
 ungroup() %>%
 mutate(total = 13474)
trios_count <- trios_count %>%
 mutate(frequency = (n/total),
        percent = ((n/total)*100))
trios_count %>% arrange(desc(percent))

write_csv(trios_count, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/MI_count_sad_noHatch_pedigree.csv")

trios_count %>% 
  filter(!is.na(MendIncLoci)) %>% 
  ggplot() +
  geom_histogram(aes(x = n), binwidth = 1)

```
Okay, one of the loci is right at the 2% mark

So the final pedigree is now...
```{r}
RR_Ped
RR_Ped %>% count(kid_age)
RR_Ped %>% count(kid_sex)
RR_Ped %>% count(kid_age, kid_sex)
RR_Ped %>% count(kid_age, kid_sex, kid_hatchery)

RR_Ped %>% filter(ma_hatchery != pa_hatchery) #3
RR_Ped %>% filter(ma_sex == pa_sex) #144
RR_Ped %>% filter(ma_sex == pa_sex) %>% count(SpawnYear)
```
Full dataset of fish from 2007-2020
```{r}
RR_meta <- reorg_rm7$snppit_meta
RR_genos <- reorg_rm7$snppit_genos

RR_meta #17535
RR_meta %>% 
  filter(grepl("Coyote_Valley|Warm_Springs", indiv)) #9
#need to remove the 9 duplicates and join the full metadata if needed?...
# maybe add the second hatchery visit to hatchery column the for indiv

RR_meta %>% 
  filter(grepl("M035090", indiv))
##oh man this might be an issue...the different ids have different dates in addition to different hatcheries. 
# it might be easier to fix this by going back to the matching sample function and change some of the code
```
okay, I'm going to take the pieces of code from reorganize_matching_samples() to try and make the date table I am envisioning...I want to add the classification of "wild" fish to the dataset
```{r}
genotypes <-  genos_na_rm7
metadata <-  rrsh_metadata  
clusters <-  for_real_rm7$clusters
#' Relabel matching genotypes to a single ID and reorganize their years and spawner groups

  # make sure that NA spawner groups are coded as ?
  metadata <- metadata %>%
    mutate(spawner_group = ifelse(is.na(spawner_group), "?", spawner_group))

  # figure out which individual to take for each cluster.
  # It will be the one with the most non-missing genotypes and, in case
  # of a tie, the one taken will be pretty much arbitrary.  Note that
  # if there are any IDs in genotypes or clusters that are not in meta data this will
  # cause a problem.  So, we semijoin on the metadata at the end.
  ids_key <- genotypes %>%
    semi_join(clusters, by = "indiv") %>%
    group_by(indiv) %>%
    summarise(num_good_genos = sum(!is.na(allele_int) / 2)) %>%
    left_join(clusters, ., by = "indiv") %>%
    arrange(cluster, desc(num_good_genos)) %>%
    group_by(cluster) %>%
    dplyr::do(tibble(retained_id = .$indiv[1], original_id = .$indiv)) %>%
    ungroup() %>%
    semi_join(metadata, by = c("original_id" = "indiv"))


  # now, we attach that result to the meta data
  matchers_meta <- ids_key %>%
    left_join(metadata, by = c("original_id" = "indiv"))

  # use the matching pairs, thus organized, to compute some reports about
  # genotype discordance, etc.
  geno_discord <- count_discrepancies(
    pairs = matchers_meta,
    genotypes = genotypes
  )

  # check for matchers that are in different hatcheries
  # and bark a message if there are any.  They have to be treated
  # a little differently.
  cross_hatchery_matches <- matchers_meta %>%
    group_by(cluster) %>%
    filter(n_distinct(hatchery) > 1)

  if (nrow(cross_hatchery_matches) > 0) {
    message("Some matching genotypes found in different hatcheries. See cross_hatchery_matches in output.")
  }

  # check for matchers that have different sexes listed
  cross_sex_matches <- matchers_meta %>%
    group_by(cluster) %>%
    filter(n_distinct(sex) > 1)

  if (nrow(cross_hatchery_matches) > 0) {
    message("Some matching genotypes found to have different sexes. See cross_sex_matches in output.")
  }

  # To deal with matchers in multiple hatcheries, we still want to use just a single genotype (with the
  # least missing data) but we will have to use a single canonical ID for each of the hatcheries that
  # the matching samples occur in.  The problem that occurs then is that we could assign an individual
  # to itself.  So, to catch those cases visually, later, we will name those canonical IDs in the other hacheries
  # as `retained-id_hatchery`.
  matchers_meta2 <- matchers_meta %>%
    group_by(cluster, retained_id) %>%
    mutate(idx_in_data = 1:n()) %>%
    group_by(cluster, retained_id) %>%
    select(cluster, everything()) %>%
    ungroup()

  # below here we are mainly compiling up the genotypes.  There is just one thing that
  # we want to do before that, however: for the retained_id fish that had matching samples
  # that showed a homozygote-to-homozygote discordance (i.e. 11 vs 44), we want to mark those
  # loci as missing in those retained_id fish.  We do that just by modifying genotypes.
  if(nrow(geno_discord$alt_homoz_mismatches) > 0) {
    make_these_na <- geno_discord$alt_homoz_mismatches %>%
      select(retained_id, locus) %>%
      rename(indiv = retained_id) %>%
      mutate(dummy__ = 1)

    genotypes %>%
      left_join(make_these_na, by = c("indiv", "locus")) %>%
      mutate(allele_int = ifelse(!is.na(dummy__), NA, allele_int)) %>%
      select(-dummy__)

    message("Rendered ", nrow(make_these_na), " genotypes NA because of mismatching homozygotes in the matching samples analysis")
  }


  # now, we need to prepare the genotypes that we will use for SNPPIT.  Firt, we want to
  # chuck the genotypes of the original_id's that were not retained
  genos_non_canon_dropped <- matchers_meta2 %>%
    filter(retained_id != original_id) %>% # this lets us keep the canonical genotypes IDs
    anti_join(genotypes, ., by = c("indiv" = "original_id"))


  # combine those to get the data set we need for SNPPIT
  snppit_genos <- genos_non_canon_dropped
  

  # now, we need to condense the meta data that we need
  # into a tibble that has combined the years and the spawn
  # groups that each individual belongs to. We can do this by grouping
  # on new_id and hatchery at this point.
  matchers_meta_snppit <- matchers_meta2 %>%
    rename(indiv = retained_id) %>%
    group_by(indiv) %>%
    summarise(
      year = paste(sort(unique(year)), collapse = ","),
      spawner_group = paste(unique(spawner_group), collapse = ","),
      hatchery = paste(sort(unique(hatchery)), collapse = ","),
      length = paste(sort(unique(length)), collapse = ","),
      watershed = paste(sort(unique(watershed)), collapse = ","),
      Wild = paste(unique(Wild), collapse = ","),
      sex = sex[1]  # just take the sex of the first (canonical) occurrence of the genotype
    ) %>%
    ungroup()

  # and we will need to combine that with all the fish that were not
  # part of the meta_matchers.  We make a data frame of all the individuals
  # that are not handled by the matchers and then we bind_rows() them and
  # arrange them nicely.
  meta_singletons <- metadata %>%
    anti_join(ids_key, by = c("indiv" = "original_id"))

  snppit_meta <- bind_rows(
    matchers_meta_snppit,
    meta_singletons %>% mutate(year = as.character(year)) %>% mutate(length = as.character(length))
  ) %>%
    arrange(hatchery, year, spawner_group)

  # now, down at the end here we return a list of outputs.
  # note that we leave the retained_id column in matchers_meta2, as it
  # can be helpful to know that
  #list(
   # matchers_metadata = matchers_meta2,
  #  snppit_meta = snppit_meta,
  #  snppit_genos = snppit_genos,
  #  cross_hatchery_matches = cross_hatchery_matches,
  #  cross_sex_matches = cross_sex_matches,
  #  geno_discord = geno_discord
  

snppit_meta #17526 fish
```

```{r}
snppit_meta %>% count(Wild)
snppit_meta %>% count(hatchery)
```
FINAL DATA:
```{r}
RR_Ped
snppit_meta

#write_csv(RR_Ped, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/RR_Pedigree_2007_2020.csv" )
#write_csv(snppit_meta, "/Users/annebeulke/Documents/Russian-River-R/Russian-River/RR_unique_individuals_2007_2020.csv" )
```
```{r}
snppit_meta %>% count(year) #looks like 68 itero fish
```
```{r}
snppit_meta %>%  count(sex)
snppit_meta %>% count(hatchery, sex)
```

```{r}
itero_fish <- snppit_meta %>% filter(grepl(",", year))%>% 
  separate(year, c("year1", "year2"), sep = ",") %>% 
  separate(spawner_group, c("date1","date2", "date3"), sep = ",") %>% 
  separate(length, c("length1", "length2"), sep = ",") %>% 
  select(indiv, sex, everything())
itero_fish %>% count(sex) #15 female, 52 male, 1 unknown sex
itero_fish
```

list of cross sex matches:
```{r}
cross_sex_matches 
cross_sex_matches %>%  count(retained_id)

fish_marked_as_both_sexes <- cross_sex_matches %>% 
  ungroup %>% 
  select(retained_id) %>% 
  unique() %>% 
  rename(indiv = retained_id)

itero_fish %>% semi_join(fish_marked_as_both_sexes, by = "indiv") #one itero fish that is marked as both Male and Female
fish_marked_as_both_sexes #26 fish 
```
```{r}
itero_as_kids %>% count(sex)
itero_as_kids %>% count(hatchery, sex)
itero_as_kids %>% filter(!is.na(pa))
itero_as_kids %>% count(kid_age)
itero_as_kids %>% count(sex, kid_age)
itero_as_kids %>% filter(!is.na(length1))
itero_as_kids %>% filter(!is.na(length2))
mean(itero_as_kids$length1, na.rm = T)
sd(itero_as_kids$length1, na.rm = T)
mean(itero_as_kids$length2, na.rm = T)
sd(itero_as_kids$length2, na.rm = T)
itero_as_kids %>% count(sex,kid_age,is.na(length1))
itero_as_kids %>% count(year1)
itero_as_kids %>% count(year1, sex, kid_age) 
```

```{r}
RR_Ped %>% count(kid_age, kid_sex, kid_hatchery)
```

```{r}
snppit_meta %>% count(year)
```

And now, lets look at the sex conflicts and see if we can identify the correct sexes based off it's mates
```{r}
library(tidyverse)
library(HatcheryPedAgree)
library(ggraph)
library(tidygraph)
#RR_Ped <- read_csv("/Users/annebeulke/Documents/Russian-River-R/Russian-River/RR_Pedigree_2007_2020.csv" )
RR_Ped
issues <- compile_pedigree_sex_issues(RR_Ped)
issues
names(issues)
issues$parent_pairs_graph
issues$sex_clash_clusters
issues$sex_unknown_clusters
issues$sex_clash_clusters_plot
issues$sex_unknown_clusters_plot

# sex clashing clusters
ggsave(
  issues$sex_clash_clusters_plot,
  filename = "clash.pdf",
  width = 30,
  height = 30
  )
# sex unknown clusters
ggsave(
  issues$sex_unknown_clusters_plot,
  filename = "unknown.pdf",
  width = 15,
  height = 15 
  )

RR_Ped %>% filter(pa_sex == ma_sex) %>% 
  mutate(pa_ma = paste(pa, ma, sep = "_")) %>% 
  count(pa_ma) %>% arrange(desc(n))

RR_Ped %>% filter(kid == "M074570")
```


